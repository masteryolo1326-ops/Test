<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Votaciones Unison — Prueba mínima</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Carga SDK Supabase v2 -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    body { font-family: system-ui, sans-serif; margin: 20px; }
    fieldset { margin-bottom: 16px; }
    button { padding: 6px 10px; }
    .hidden { display: none; }
    table { border-collapse: collapse; margin-top: 12px; }
    td, th { border: 1px solid #ccc; padding: 4px 8px; }
    #toast { position: fixed; right: 12px; top: 12px; background:#333; color:#fff; padding:8px 12px; border-radius:6px; display:none; }
  </style>
</head>
<body>
  <h1>Votaciones UNISON — Demo funcional mínima</h1>

  <div id="toast"></div>

  <!-- LOGIN -->
  <fieldset id="loginBox">
    <legend>Iniciar sesión</legend>
    <label>Email @unison.mx:
      <input id="email" type="email" placeholder="tu@unison.mx" required />
    </label>
    <label>Contraseña:
      <input id="password" type="password" placeholder="********" required />
    </label>
    <button id="btnLogin">Entrar</button>
    <button id="btnRecover">Recuperar contraseña</button>
    <div id="loginMsg"></div>
  </fieldset>

  <!-- APP -->
  <div id="app" class="hidden">
    <p>Sesión: <span id="uid"></span> <button id="btnLogout">Salir</button></p>

    <fieldset>
      <legend>Votar</legend>
      <div id="candidates"></div>
    </fieldset>

    <fieldset>
      <legend>Resultados (realtime)</legend>
      <div>Total votos: <span id="totalVotes">0</span></div>
      <table>
        <thead>
          <tr><th>Candidato</th><th>Votos</th><th>%</th></tr>
        </thead>
        <tbody id="results"></tbody>
      </table>
    </fieldset>
  </div>

<script>
/** ======= CONFIGURACIÓN (ajusta si es necesario) ======= **/
const SUPABASE_URL = "https://slcewcigqiauczwknedt.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNsY2V3Y2lncWlhdWN6d2tuZWR0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjEyNzExOTcsImV4cCI6MjA3Njg0NzE5N30.FDsk0JHxIqumSDb8VnHM9SaB8czrTZ5-hVfwb4ekwlA";

/** ======= CLIENTE SUPABASE (singleton) ======= **/
(function ensureSingleton(){
  if (!window.__supa) {
    window.__supa = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: { persistSession: true, autoRefreshToken: true, storageKey: "unison-votaciones-demo" }
    });
  }
  window.supa = window.__supa;
})();

/** ======= ESTADO SIMPLE ======= **/
const state = {
  userId: null,
  hasVoted: false,
  candidates: [
    { id: 1, name: "Planilla 1" },
    { id: 2, name: "Planilla 2" },
    { id: 3, name: "Planilla 3" },
    { id: 4, name: "Planilla 4" }
  ],
  channel: null
};

const $ = (id) => document.getElementById(id);
function toast(msg, ms=2500){ const t=$('toast'); t.textContent=msg; t.style.display='block'; setTimeout(()=>t.style.display='none', ms); }
function isInstitutionalEmail(email){ return /@unison\.mx$/i.test(email.trim()); }

/** ======= UI ======= **/
function show(section){
  $('loginBox').classList.toggle('hidden', section !== 'login');
  $('app').classList.toggle('hidden', section !== 'app');
}
function renderCandidates(){
  const box = $('candidates');
  // Desactiva botones si ya votó
  box.innerHTML = state.candidates.map(c => 
    `<button data-id="${c.id}" ${state.hasVoted ? 'disabled' : ''}>Votar por ${c.name}</button>`
  ).join(' ');
  box.querySelectorAll('button').forEach(btn=>{
    btn.onclick = () => confirmVote(parseInt(btn.dataset.id,10));
  });
}
function renderResults(rows){
  const total = rows.reduce((a,r)=> a + (r.count||0), 0);
  $('totalVotes').textContent = total;
  const byId = new Map(rows.map(r => [r.candidate_id, r.count||0]));
  $('results').innerHTML = state.candidates.map(c=>{
    const v = byId.get(c.id) || 0;
    const pct = total ? ((v/total)*100).toFixed(1) : "0.0";
    return `<tr><td>${c.name}</td><td>${v}</td><td>${pct}%</td></tr>`;
  }).join('');
}

/** ======= AUTH ======= **/
async function checkSession(){
  const { data: { session }, error } = await supa.auth.getSession();
  if (error) console.warn('getSession:', error);
  if (session?.user) {
    state.userId = session.user.id;
    $('uid').textContent = state.userId;
    show('app');
    await refreshAll();
    subscribe();
  } else {
    state.userId = null;
    $('uid').textContent = '—';
    show('login');
  }
}

$('btnLogin').onclick = async () => {
  const email = $('email').value.trim();
  const password = $('password').value;
  if (!isInstitutionalEmail(email)) { toast('Usa tu correo @unison.mx'); return; }
  if (!password || password.length < 6) { toast('Contraseña mínima 6 caracteres'); return; }
  try {
    const { error } = await supa.auth.signInWithPassword({ email, password });
    if (error) throw error;
    toast('Sesión iniciada');
    await checkSession();
  } catch (e) {
    console.error(e);
    toast(e.message || 'Error de autenticación');
  }
};

$('btnRecover').onclick = async () => {
  const email = $('email').value.trim();
  if (!isInstitutionalEmail(email)) { toast('Escribe tu correo @unison.mx y vuelve a intentar'); return; }
  try {
    const { error } = await supa.auth.resetPasswordForEmail(email, { redirectTo: location.origin });
    if (error) throw error;
    toast('Correo de recuperación enviado');
  } catch (e) {
    console.error(e);
    toast(e.message || 'No se pudo enviar recuperación');
  }
};

$('btnLogout').onclick = async () => {
  await supa.auth.signOut();
  unsubscribe();
  state.hasVoted = false;
  show('login');
};

/** ======= VOTO ======= **/
async function confirmVote(candidateId){
  if (!state.userId) { toast('Debes iniciar sesión'); return; }
  if (!confirm(`¿Confirmas tu voto por ${state.candidates.find(c=>c.id===candidateId)?.name}?`)) return;
  try {
    const { error } = await supa.from('votes').insert({ user_id: state.userId, candidate_id: candidateId });
    if (error) {
      if (error.code === '23505') {
        state.hasVoted = true;
        renderCandidates();
        toast('Ya habías votado');
        return;
      }
      throw error;
    }
    state.hasVoted = true;
    renderCandidates();
    toast('Voto registrado');
    await loadResults();
  } catch (e) {
    console.error(e);
    toast(e.message || 'No se pudo registrar el voto');
  }
}

/** ======= DATA ======= **/
async function loadResults(){
  // SELECT agrupado: candidate_id, count(*)
  const { data, error } = await supa
    .from('votes')
    .select('candidate_id, count:count(*)')
    .group('candidate_id');
  if (error) {
    console.error('loadResults:', error);
    toast('No se pudieron cargar resultados');
    return;
  }
  renderResults(data || []);
}

async function checkIfUserHasVoted(){
  if (!state.userId) { state.hasVoted = false; return; }
  const { data, error } = await supa
    .from('votes')
    .select('id')
    .eq('user_id', state.userId)
    .maybeSingle();
  if (error && error.code !== 'PGRST116') {
    console.warn('checkIfUserHasVoted:', error);
  }
  state.hasVoted = Boolean(data);
  renderCandidates();
}

async function refreshAll(){
  renderCandidates();
  await loadResults();
  await checkIfUserHasVoted();
}

/** ======= REALTIME ======= **/
function subscribe(){
  unsubscribe();
  state.channel = supa
    .channel('votes-stream')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'votes' }, async () => {
      await loadResults();
      await checkIfUserHasVoted();
    })
    .subscribe();
}
function unsubscribe(){
  if (state.channel) {
    supa.removeChannel(state.channel);
    state.channel = null;
  }
}

/** ======= BOOT ======= **/
if (location.protocol === 'file:') {
  console.warn('Serve este archivo con http(s), no file://');
}
checkSession();
supa.auth.onAuthStateChange((_e, session) => {
  state.userId = session?.user?.id || null;
});
</script>

<!--
SQL necesario (en tu proyecto Supabase):

create table if not exists public.votes (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  candidate_id int not null check (candidate_id between 1 and 4),
  created_at timestamp with time zone default now(),
  unique (user_id)
);
alter table public.votes enable row level security;
create policy "insert own vote" on public.votes for insert to authenticated with check (auth.uid() = user_id);
create policy "read votes" on public.votes for select to authenticated using (true);
-->
</body>
</html>
